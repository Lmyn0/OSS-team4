"""
Kruskal 알고리즘을 사용한 미로 생성

Usage:
    python maze_pygame.py --width 20 --height 15 --seed 12345 --delay 0.01 --cell 24
"""

import sys
import argparse
import random
import time
import pygame

# 방향
N, S, E, W = 1, 2, 4, 8
DX = {E: 1, W: -1, N: 0, S: 0}
DY = {E: 0, W: 0, N: -1, S: 1}
OPPOSITE = {E: W, W: E, N: S, S: N}

# --- union-find 트리 ---
class Tree:
    def __init__(self):
        self.parent = None

    def root(self):
        return self.parent.root() if self.parent else self

    def connected(self, other):
        return self.root() is other.root()

    def connect(self, other):
        # 다른 트리의 루트를 자기 자신에 연결
        other.root().parent = self

# --- Kruscal 알고리즘을 통한 미로 생성 ---
def generate_maze(width, height, seed, step_callback=None):
    rand = random.Random(seed)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    sets = [[Tree() for _ in range(width)] for _ in range(height)]

    edges = []
    for y in range(height):
        for x in range(width):
            if y > 0:
                edges.append((x, y, N))
            if x > 0:
                edges.append((x, y, W))

    rand.shuffle(edges)

    while edges:
        x, y, direction = edges.pop()
        nx, ny = x + DX[direction], y + DY[direction]
        set1, set2 = sets[y][x], sets[ny][nx]

        if not set1.connected(set2):
            if step_callback:
                step_callback(grid, width, height)

            set1.connect(set2)
            grid[y][x] |= direction
            grid[ny][nx] |= OPPOSITE[direction]
            
            if step_callback:
                step_callback(grid, width, height)

    # 최종 상태 콜백
    if step_callback:
        step_callback(grid, width, height)
    return grid

# --- Pygame을 통해 미로 그리기 ---
def draw_maze(surface, grid, width, height, cell, wall_thickness=2):
    surface.fill((255, 255, 255))  # 흰색
    # 외각 크기
    w_px = width * cell
    h_px = height * cell

    # 벽 : 검은색 선, 벽이 없는 부분 : 길
    for y in range(height):
        for x in range(width):
            cx = x * cell
            cy = y * cell
            cell_bits = grid[y][x]

            # 위쪽 벽
            if not (cell_bits & N):
                pygame.draw.line(surface, (0,0,0), (cx, cy), (cx + cell, cy), wall_thickness)
            # 왼쪽 벽
            if not (cell_bits & W):
                pygame.draw.line(surface, (0,0,0), (cx, cy), (cx, cy + cell), wall_thickness)
            # 아래쪽 벽
            if not (cell_bits & S):
                pygame.draw.line(surface, (0,0,0), (cx, cy + cell), (cx + cell, cy + cell), wall_thickness)
            # 오른쪽 벽
            if not (cell_bits & E):
                pygame.draw.line(surface, (0,0,0), (cx + cell, cy), (cx + cell, cy + cell), wall_thickness)


    pygame.display.get_surface().blit(surface, (0,0))
    pygame.display.flip()

# --- 메인 실행행 ---
def시
        screen.blit(surface, (0,0))
        info_surf = info_font.render(info_text, True, (0,0,0))
        screen.blit(info_surf, (4, 4))
        pygame.display.flip()
        clock.tick(30)

if __name__ == '__main__':
    main()
